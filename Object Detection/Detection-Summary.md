1. 检测的应用
第一个是做人脸检测，这个做完检测之后还会有很多应用，比如人脸识别会先去检测这个人脸，还有人脸的特征点定位。就是检测到人脸之后，再去点击鼻子，做一些美化或者是其他的特效，还有旁边行人的检测。下面是车行的检测，这个在交通当中应用是很多的。比如说首先需要检测到这些车，再去对这些车进行分类，看看这些车是什么车。

2. 常用检测框架
这些检测的方法我大体上分为三类：一是 Cascade CNN，这是一个 CNN 的结构；二是 RCNN 相关的，这里面我列了几种，当然还有特别多的优化这里没有放出来。包括 RCNN，然后 FastRCNN、FasterRCNN 和 R-FCN、PVANet。三是 YOLO、SSD。
a)Cascade CNN
首先说一下 Cascade CNN，我们做目标检测的时候有一种非常暴力的方法就是用一个框去辨别这个图像，做一些分类。比如第一个框我框出来了，用一个分类器去分类，比如我这里检测是人脸，我就去做分类，看看这个框里面是不是人脸，我去扫一遍的话，扫到一个区域是人脸。如果我分类的概率大于某一个阈值的话，输出这个地方是人脸，这是一种非常暴力的方法。针对这个方法我们有很多的改进，比如说这里会有很多框，几万个框计算代价太高了，我会先初步的做一个筛选，比如先用一些大的框去扫，扫到某一个区域可能有人脸，我再对这个区域进行检测。这样的话，我通过一个极连的步骤，可以大大的减少计算的时间。更详细的方法在下面，大家有兴趣可以去看一下，它主要是针对暴力扫的话，这种极连不断的去减少这种计算复杂度的方法。（附该结构的 Github 代码地址 https://github.com/anson0910/CNN_face_detection）
b)RCNN
RCNN 是目标检测里面的一个开放性的模块，其他的主要思想也和刚才的类似。刚才在扫这个区域的过程当中有三步：第一步去决定一些框，第二步要对这个框进行分类，第三步要根据我刚才得到的这些框好输出最后的结果。这三步 CRNN 里面做了相应的改进。第一步刚才我们的框是暴力的，RCNN 里面会有一个 Region Proposal 的方法，先看哪些地方有物体，先把这些框作为候选的区域，大概只有 2000 个，比刚才要小特别多。得到这些候选框之后，第二步我们要对这个框进行分类，都有一个卷积神经网络，这个卷积神经网络针对这个框，比如我们常用的是 24×24 的，通过卷积神经网络最后的全链接，一般是 4.96，得到一个 4096 位的特征。得到这个特征之后，我们有些常见的特征，对每一类进行训练一个分类器，我们就可以判断出来，比如提取这一项之后进行分类是机器还是人。这个改进了刚才的三步：第一步就是我们用 Region Proposal 的方法替代暴力扫的方法；第二步就是用 CNN 的特征做分类，不是用传统的一些特征；第三步是用一个 SVM 的分类对候选区域进行分类。这里面还有一个改进，就是我这个候选区域框的位置可能不对，这个人就提出来一个框的回归方法，就去纠正这个 Proposal 的位置，这样的话也带来一个检测效果的提升。（附该结构的 Github 代码地址：https://github.com/rbgirshick/rcnn）
实际上在这里还有一个改进就是，比如说在这个 CNN 的部分，我们一般是用这个模型直接去提这个 4096 位的特征。这样的话就会导致一个问题，就是说你的模型是在这个上面训练的，但是应用在这个检测的里面，可能我的数据跟你原始数据的分布是有一定差异的，它会把这个模型拿过来，在我的检测数据上面进行一些微调。微调的意思就是说，比如这里分类一般是 1000 类，我把这 1000 类，这个检测只有 21 类的话，把这个全链接层换掉，把这个网络拿到我的数据下面训练一下，会带来很大的分类效果的提升。最后综合这三步，RCNN 相对于传统的目标检测的方法效率、速度和精度上都有了特别大的提升。下面的工作基本上都是针对这三步分别进行改进。
c)FastRCNN
FastRCNN 部分，刚才在目标检测的后两步，要针对每个区域先提取特征，然后再分类，FastRCNN 就是想把这两步融合起来作为一步。这里就提出来 ROI 的方法，其实就是刚才的这个候选时序。第二步就是设计了这一部分，实现了一个 End to End 的训练。这个当中一个核心的 ROI 有一个解释，这张图片通过我的一些卷积层，比如任何一个网络，我会得到一个 Feature Map，这是 N×W，相当于一般的卷积神经网络最后的卷积层。针对我下面这个候选区域，我会把我的候选区域分为一些块，比如说常用的我会分成 7×7 的一共 49 个，分成 49 个之后，我会把这个区域映射到对应的 Feature Map 这个区域当中。这里有一个特殊的方法，一般的神经网络有四个值我取一个最大的。这里是针对这个区域，比如左上角的区域是取一个值，针对大的或者小的输入，都会生成一个特征向量，这样的话就会解决这个问题，虽然我的候选区域大小不同，但是我最后得到的特征维数是一样的，这样的话就可以做一个批处理。最后通过这里有一个分类的损失和合规的损失，就可以分配到这个序列。（附该结构的 Github 代码地址：https://github.com/rbgirshick/fast-rcnn）
d)FasterRCNN
FastRCNN 解决了刚才这三步当中的一步，还有一个部分没有解决，要去提这个候选框，这个是非常耗时的。FasterRCNN 就解决这个问题，看能不能通过深度学习直接提出这些候选框。这里有一个非常好的设计是 Anchors，比如刚才我通过一张图得到一个 Feature Map 之后，比如这个是 H×W 的话，那么我对于这个 Feature Map 上面，我认为这个点会默认的存在一些光。在 FasterRCNN 当中，我把这个原图做了一个可视化，比如我默认这个点大概存在 9 个不同的框，这个框我设计完之后就可以直接从图片里得到这些框，也会针对每一个框输出。比如你默认设置一个 K 框的话，会默认得到一个分类的框，还有一个是坐标 4。这里只是分类物体，就相当于解决了刚才的提取框，哪些为了可能存在物体。通过 Region Proposal Network，用一个简单的网络可以达到每秒 14 帧的处理速度。当然这里面有很多训练的细节，大家如果感兴趣的话可以看一看。

我这里给了一个 FasterRCNN 一个整体的结构。比如这里是图片的话，这里是我们常用的卷积网络，在这里得到我的 Feature Map，就是这个地方。通过这个 Feature Map 有两个分支，通过这个 Feature Map 可以提刚才的候选区域，通过候选区域又映射回刚才得到的这个特征，Feature Map 就相当于提取了某一个候选区域的特征，这里再加一些全链接层或者卷积层，直接得到它的结构。我们可以看到，整个就是一个端对端的训练。这里是 FasterRCNN 的一个介绍。（附该结构的 Github 代码地址：https://github.com/rbgirshick/py-faster-rcnn）
e)RFCN
下面是 RFCN 的结构。RFCN 解决了什么问题呢？在刚才的这个图当中，如果这里得到了 2000 个的候选区域，每一个区域都要进行分类，这一部分要运算 2000 次，这个特别是在残差网络，在运行过程当中，会把最后的做分类，这样的话预算代价特别高，RFCN 的提出就是为了解决这个问题。这里也是设计了一种特殊的呼应的方法，就是刚才通过这张图得到了我的特征图之后，向大家强制输出跟我的类别相关的一个特征图的数目，比如我一般是 256 个，我把这里强制输出是乘以类别数的 Feature Map。这里有什么好处呢？这个好处就是，我针对每一个类别，比如我输出的是九个 Feature Map，，这里是特征图，这是对应到特征图的区域，把这个分为九块。做铺列的时候，针对第一个 Feature Map 图只举左上的一小块进行铺列，得到第一个图，第二个得到第二个图，九个特征图最后得到九个小块。这个是跟刚才 FasterRCNN 里面是一样的，我这里也给了一个 RFCN 整体的架构，这一部分跟刚才不一样，我如果得到特征图之后，这里是一个新加的卷积层，这里是让大家强制输出成和我类别数相关的一个卷积层，就是 Feature Map 的数目，这边是一个分类，这边是采用刚才这种铺列的方法，最后也得到了检测的结果。这里是一个效果对比图，FasterRCNN 的话速度是 420 毫秒一张图，通过这个简化之后，RFCN 是 170 毫秒一张图，相当于提升了三倍的速度。对应的准确率比 FasterRCNN 要高。（附该结构的 Github 代码地址: https://github.com/daijifeng001/caffe-rfcn）
f)PVANET
这一部分介绍的是 PVANET。我们常用的这一部分，通过图像得到这个特征图的时候，我们一般常用的是这些网络，这个提特征值的时候有没有更好的网络设计？PVANET 对这一部分做了三步改进：第一步使用了 CReLU 的激活方法，一般的卷积层比如有 200 个，会输出 256 个 Feature Map，这相当于有一大部分是冗余的，这个 CReLU 就可以让输出的数量变少，比如 256 个 Feature Map 变成 128 个，这样的话就可以减少预算量。第二步是引入 Inception 网络，Inception 模块是有多个不同大小的卷积组合，得到下一层的 Feature Map。这样有一个好处就是说，相当于做了一个特征的融合，就是说我得到的特征是有不同的特征，不同大小的卷积得到的特征。第三步是把卷积神经网络不同层的输出进行结合，这里有一个什么好处呢？比如说一个网络有五层的话，第五层可能是结构化信息非常高的。这样的话，可能对一些小的物体，这些小的物体到高层的话损失特别大。这里就把低层的 Feature Map 和高层的 Feature Map 进行融合，得到了最后的这个，这一层包含的信息比传统的信息更多。而且更重要的是，这里通过一些设计，让卷积层 Feature Map 的数量变少，达到了很大速度的提升。下面这个图可以看出来，PVANET 可以达到 46 毫秒一张图，比刚才的 RFCN 还要快，刚才的 RFCN 是 133 毫秒，这样就可以达到一个实时的效果，大约 120 帧 1 秒的速度，而且是不同的融合方法，最后检测的准确率是非常高的。（附该结构的 Github 代码地址: https://github.com/lvchigo/PVANet_train）
g)YOLO
YOLO 的出发点是什么呢？在刚才这个检测流程当中，我通过这里得到一个 Feature Map 之后，先要在这个 Feature Map 上面得到一些候选区域，又要针对这些候选区域，再从这个 Feature Map 上面提一遍特征。这里会造成对每一个候选区域要做两次预算，这里等于是不需要的。下面的方式就是直接从图片得到最后分类检测的框。YOLO 就是把一张图分为很多的区域，对于一张图有一个狗，怎么对应呢？我的中心框如果对着这里，这里就负责解决这个问题，这里得到最后的结果。这个自行车对应到这个点，轿车对应到这个点，最后直接通过这个网络得到一个输出。这里要注意的是，这个输出可以看到是 7×7×30 的矩阵。首先要判断是什么物体，在这个检测当中是 20 倍，在这里有 20 维去表示是什么物体。还有 8 维，要对这个框的位置进行修正，这 8 维是负责对这个框的区域进行修正。
下面是它的整个网络的设计图，这里一共有 24 层的卷积，这里直接通过图片，448×448，最后得到 7×7×30。通过这 30 维，就直接可以算出一个 49 个格子当中，每个格子可能包含什么物体，在什么位置。这样的话，我一次运算就得到了最后的检测结果。这里训练还有一些细节，就比如说这个网络的初始化，会先把一些卷积层在更大的范围内预训练一下，采用 RCNN 的方法，最后再拿到检测训练。这个后面还做一些改进，大家有兴趣的话也可以关注一下。（附该结构的 Github 代码地址：https://github.com/xingwangsfu/caffe-yolo）
h)SSD
下面是 SSD 的结构，SSD 是这个比赛当中用的很多的一种方法。它解决的是什么问题呢？刚才 YOLO 看上去是非常暴力的，一个图片直接分为 49 个格子。这样的话，如果是这种小的物体的话，可能检测效果会更好。SSD 做了这个改进，比如说看这个网络当中，这里前面是一个 16 层的，到这里如果是 300×300 的话会输出一个 38×38×512，针对这 38× 38 我们会在每一个点上预设一些默认的框，这个地方和前面 FasterRCNN 的 Anchors 有点像，YOLO 只在这个地方输入了一个。SSD 是在网络当中不同的层都有输出。这样的话，其实也相当于一些特征的磨合。当然这个 SSD 在实际的训练当中还有非常多的训练的策略，比如说一个图片是 300×300，之前要做一些图像的增强，可以剪切一些区域去做训练，如果大家对这个感兴趣的话可以看一下这个论文。这里是 SSD 的一个检测效果。我们刚才把这个网络定位一致的话，都用 VGG16 的话 FPS 是 7。这个 SSD 做检测的时候有一个地方，这里是一个 Match 的检测，每次可以处理 8 张图片同时做检测，如果大家去测这个速度的话可能会有损失。（附该结构的 Github 代码地址: https://github.com/zhreshold/mxnet-ssd）
3. 所述框架总结
Deep Learning 的运用 CNN 的方法去提取物体的特征，比传统手动设置的特征更好，这样带来检测的准确度更高。我们引入了回归的方法，对于检测的位置做一些修正，这样的话检测的位置是更准的。刚才我介绍的这几个框架都是端对端的，这样的话，可以让我的检测速度非常快，而且可以用到 GPU 加度。
